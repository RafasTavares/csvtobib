package ch.unibe.scg.csvtobib;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.jbibtex.BibTeXDatabase;
import org.jbibtex.BibTeXEntry;
import org.jbibtex.BibTeXFormatter;

/**
 * (IEEE) CSV to BibTeX.
 */
public class Main {

	/**
	 * Main method.
	 *
	 * @param args the command line arguments.
	 */
	public static void main(String[] args) {

		// parse command line arguments
		final CommandLineArguments cla = new CommandLineArguments(Main.class, args);
		final CommandLineArguments.Argument fileArg = cla.add(
				"A (IEEE) CSV file to convert to BibTeX.",
				"<file>",
				"f", "file"
		);
		final CommandLineArguments.Argument dirArg = cla.add(
				"The output directory where to put the BibTeX file. (OPTIONAL)",
				"<file>",
				"d", "directory"
		);
		final CommandLineArguments.Argument usageArg = cla.add(
				"Print the usage of this program.",
				"",
				"u", "usage"
		);

		if (args.length == 0 || usageArg.isSet() || !CommandLineArguments.areAllSet(fileArg)) {
			cla.printUsage();
			kthxbai();
		}

		final File inputFile = new File(fileArg.getString());
		if (!inputFile.exists()) {
			printError("ERROR: input file does not exists: " + inputFile);
			kthxbai();
		}
		if (!isCSVFile(inputFile)) {
			printError(
					"ERROR: input file is not a CSV file: " + inputFile,
					"...so far I'm really just checking the file extension. Make sure it's \".csv\"."
			);
			kthxbai();
		}
		System.out.println("input file: " + inputFile);

		File outputDirectory = null;
		if (!dirArg.isEmpty()) {
			outputDirectory = new File(dirArg.getString());
			if (!outputDirectory.exists()) {
				System.out.println("creating output directory: " + outputDirectory);
				outputDirectory.mkdirs();
			}
		}
		// just put output file where the input file is if no directory is specified
		if (outputDirectory == null) {
			outputDirectory = inputFile.getParentFile();
		}
		final File outputFile = new File(
				outputDirectory,
				getBibTeXFilename(inputFile)
		);
		System.out.println("output file: " + outputFile);

		// peek at file and try to figure out if we have some (header) lines
		// to skip (IEEE puts one there, so...)
		boolean skipFirstLine = false;
		try (BufferedReader reader = new BufferedReader(new FileReader(inputFile))) {
			final String line = reader.readLine();
			if (line != null) {
				skipFirstLine = line.contains("ieeexplore.ieee.org");
			}
		} catch (IOException ex) {
			printError(ex, "ERROR: failed to read the input file: " + inputFile);
		}

		// read csv file, and create/fill new BibTeX database
		System.out.println("parsing CSV file: \"" + inputFile + "\"...");

		final BibTeXDatabase database = new BibTeXDatabase();
		final BibTeXDatabase rejected = new BibTeXDatabase();

		final CSVToBibTeX ctb = getCsvToBibTeX(IEEE_CSVToBibTeX.class);
		extractDatabase(inputFile, skipFirstLine, database, rejected, IEEE_CSVToBibTeX.class);

		final int numBibTeXEntries = database.getEntries().size();
		final int numInvalidEntries = ctb.getNumInvalidEntries();
		final int numAutoKeys = ctb.getNumAutoGeneratedKeys();
		System.out.println("number of BibTeX entries created: " + numBibTeXEntries);
		System.out.println("number of invalid/rejected BibTeX entries: " + numInvalidEntries);
		System.out.println("number of auto. generated keys: " + numAutoKeys);

		// write BibTeX database to disk
		if (numBibTeXEntries > 0) {
			System.out.println("writing BibTeX database to: \"" + outputFile + "\"...");
			writeBibTeXDatabase(database, outputFile);
		}

		// write rejected BibTeX database to disk
		if (numInvalidEntries > 0) {
			final File rejectedFile = new File(
					outputDirectory,
					getRejectedBibTeXFilename(inputFile)
			);

			System.out.println("writing rejected BibTeX database to: \"" + rejectedFile + "\"...");
			writeBibTeXDatabase(rejected, rejectedFile);
		}

		kthxbai();
	}

	public static void kthxbai() {
		System.out.println("\nkthxbai.");
		System.exit(0);
	}

	public static void printError(String... messages) {
		printError(null, messages);
	}

	public static void printError(Exception ex, String... messages) {
		for (String msg : messages) {
			System.err.println(msg);
		}
		if (ex != null) {
			ex.printStackTrace(System.err);
		}
	}

	public static Writer newFileWriter(File file) throws UnsupportedEncodingException, FileNotFoundException {
		return new BufferedWriter(new OutputStreamWriter(
				new FileOutputStream(file),
				StandardCharsets.UTF_8
		));
	}

	public static void writeBibTeXDatabase(BibTeXDatabase database, File file) {
			try (Writer writer = newFileWriter(file)) {
				final BibTeXFormatter formatter = new BibTeXFormatter();
				formatter.format(database, writer);
			} catch (UnsupportedEncodingException ex) {
				printError(ex, "ERROR: failed to write database to: " + file);
			} catch (IOException ex) {
				printError(ex, "ERROR: failed to write database to: " + file);
			}
	}

	// we just check the file extension here, s.t. the following call to
	// getBibTeXFilename doesn't crash...
	public static boolean isCSVFile(File file) {
		final String filename = file.getName();
		final int n = filename.lastIndexOf('.');
		return "csv".equalsIgnoreCase(filename.substring(n + 1));
	}

	public static String getBibTeXFilename(File file) {
		final String filename = file.getName();
		final int n = filename.lastIndexOf('.');
		return filename.substring(0, n + 1) + "bib";
	}

	public static String getRejectedBibTeXFilename(File file) {
		final String filename = file.getName();
		final int n = filename.lastIndexOf('.');
		return filename.substring(0, n) + "-rejected.bib";
	}

	public static <T extends Enum<T> & CSVToBibTeX> CSVToBibTeX getCsvToBibTeX(Class<T> csvToBibTeX) {
		final T[] fields = csvToBibTeX.getEnumConstants();
		return fields[0];
	}

	public static <T extends Enum<T> & CSVToBibTeX> BibTeXDatabase extractDatabase(File csvFile, boolean skipFirstLine, BibTeXDatabase database, BibTeXDatabase rejected, Class<T> csvToBibTeX) {
		try (InputStreamReader reader = newReader(new FileInputStream(csvFile))) {
			if (skipFirstLine) {
				skipLine(reader);
			}
			final CSVParser parser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader());
			for (CSVRecord record : parser) {
				final BibTeXEntry entry = extractRecord(record, csvToBibTeX);
				if (isValidEntry(entry, csvToBibTeX)) {
					database.addObject(entry);
				} else {
					rejected.addObject(entry);
				}
			}
		} catch (IOException ex) {
			printError(ex, "ERROR: failed to read the input file: " + csvFile);
		}

		return database;
	}

	public static void skipLine(InputStreamReader reader) throws IOException {
		int c;
		while ((c = reader.read()) > 0) {
			if (c == '\n') {
				return;
			}
		}
	}

	public static InputStreamReader newReader(final InputStream inputStream) {
		return new InputStreamReader(
				new BOMInputStream(inputStream),
				StandardCharsets.UTF_8
		);
	}

	public static <T extends Enum<T> & CSVToBibTeX> BibTeXEntry extractRecord(CSVRecord record, Class<T> csvToBibTeX) {
		final T[] fields = csvToBibTeX.getEnumConstants();
		final CSVToBibTeX f = fields[0];
		final org.jbibtex.Key recordType = f.getBibTeXEntryType(record);
		final org.jbibtex.Key recordKey = new org.jbibtex.Key(
				f.getBibTeXKey(recordType, record)
		);
		final BibTeXEntry entry = new BibTeXEntry(recordType, recordKey);
		for (CSVToBibTeX field : fields) {
			final String value = field.extract(recordType, record);
			if (!value.isEmpty()) {
				entry.addField(
						field.getBibTeXField(),
						new org.jbibtex.StringValue(
								value,
								org.jbibtex.StringValue.Style.BRACED
						)
				);
			}
		}
		return entry;
	}

	public static <T extends Enum<T> & CSVToBibTeX> boolean isValidEntry(BibTeXEntry entry, Class<T> csvToBibTeX) {
		return getCsvToBibTeX(csvToBibTeX).isValidEntry(entry);
	}

}
